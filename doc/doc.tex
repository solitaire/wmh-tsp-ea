\documentclass[12pt, a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{polski}
\usepackage{hyperref}
\usepackage{float}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{geometry}
\title{\textbf{Zastosowanie algorytmu ewolucyjnego do rozwiązywania problemu komiwojażera}}
\author{Anna Stępień \\ Adam Stelmaszczyk}
\date{}
\setlength{\parindent}{0in}
\makeatletter\renewcommand{\ALG@name}{}

\begin{document}
\maketitle

\section{Zadanie}
Celem zadania jest zaprojektowanie algorytmu ewolucyjnego, który zostanie wykorzystany do rozwiązania problemu komiwojażera.
Zaprojektowana została reprezentacja rozwiązania, metoda sukcesji oraz operatory mutacji i krzyżowania. 
Z punktu widzenia przydatności projektowanego algorytmu, istotne jest przetestowanie go dla różnych parametrów, w szczególności dla:
\begin{itemize}
	\item różnych wartości prawdopodobieństwa mutacji $p_m$ i krzyżowania $p_c$,
	\item grafów o różnej liczbie wierzchołków $n$.
\end{itemize}

\section{Założenia}
Aplikacja będzie pracować w trybie konsolowym. Na standardowe wejście podawane będą pliki tekstowe zawierające opis grafów.
Program będzie wypisywał odpowiedź na standardowe wyjście.

\subsection{Reprezentacja rozwiązań}

Wierzchołki grafu numerujemy od 0 do $n - 1$. $n > 2$. Rozwiązanie reprezentujemy jako ciąg długości $n$, złożony z unikalnych liczb. 
Dla skrócenia zapisu stosujemy zapis 123, zamiast $(1,2,3)$. Przykładowo, w grafie pełnym o 3 wierzchołkach możliwych jest $3!$ rozwiązań: 123, 132, 213, 231, 312, 321.
Warto zauważyć, że połowę tych rozwiązań można pominąć, ze względu na to, że koszt przejścia z $a$ do $b$ jest zawsze 
taki sam jak z $b$ do $a$. Można zatem pominąć rozwiązania $231, 312, 321$. Pozostałe trzy rozwiązania mają identyczny koszt,
zatem dwa z nich również można pominąć. Tym samym jedyne interesujące nas rozwiązanie to $123$.
W ogólnym przypadku, dla grafu pełnegoo $n$ wierzchołkach, liczba interesujących nas rozwiązań wynosi $\frac{(n-1)!}{2}$. Spośród redundantnych rozwiązań pozostawiane będą te,
których reprezentacja liczbowa jest najmniejsza. Przykładowo, dla grafu pełnego o $4$ wierzchołkach zamiast rozpatrywać wszystkie
24 rozwiązania, będziemy rozpatrywać tylko 3: 1234, 1324, 1342. 
Wartość funkcji celu $f$ to suma wag krawędzi w cyklu dla danego rozwiązania.

\subsection{Schemat algorytmu ewolucyjnego}

\begin{algorithm}[!htb]
\label{ea}
\begin{algorithmic}[1]
\Function{algorytm\_ewolucyjny}{}
	\State $P(0) \gets \{x_1, x_2, \ldots, x_n\}$
	\State $t \gets 0$
	\While{$! stop$}
    	\For{$i = 0$ \bf{to} $i = n - 1$}
    		\If{$U(1) < p_c$}
    			\State $O(t,i) \gets mutacja(crossover(selekcja(P(t), 2)))$
    		\Else
    			\State $O(t,i) \gets mutacja(selekcja(P(t),1))$
    		\EndIf
    	\EndFor
    \State $P(t+1) \gets sukcesja(P(t),O(t))$
    \State $t \gets t+1$
  	\EndWhile
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Operator mutacji}

Operator mutacji otrzymuje na wejściu prawdopobieństwo mutacji $p_m$ oraz rozwiązanie długości $n$.
Zwraca rozwiązanie długości $n$.

\begin{enumerate}
 \item Liczba powtórzeń $R = \lceil n \cdot  p_m \rceil$. Powtórz $R$ razy następujące kroki:
 \item Wylosuj indeks $i$ od 0 do $n-1$ zgodnie z rozkładem jednostajnym.
 \item Wylosuj indeks $j$ od 0 do $n-1$, ale różny od $i$, zgodnie z rozkładem jednostajnym.
 \item Zamień liczbę na pozycji $i$-tej w ciągu z liczbą na pozycji $j$-tej.
\end{enumerate}

\subsection{Operator krzyżowania}

Operator krzyżowania na wejściu otrzymuje dwa rozwiązania rodzicielskie długości $n$ i zwraca dwa rozwiązania potomne długości $n$. 
Jako operator krzyżowania zostanie wykorzystany operator krzyżowania {PMX}[referencja by sie przydała] (z częściowym odwzorowaniem).
Operator krzyżowania jest opisany dwoma punktami krzyżowania: $i$, $j$.
\begin{enumerate}
 \item Dla sekwencji od $i$ do $i+j$ dokonaj wymiany, % hmm jak on tej wymiany dokonuje? %
 \item Skopiuj pozostałe części sekwencji (od $0$ do $i-1$ i od $j+1$ do $n$), dokonując niezbędnych zmian, aby rozwiązania potomne były permutacjami.
 % tez takie czary-mary troche, nie wiem jak wygladaja te niezbędne zmiany  %
\end{enumerate}

\subsection{Metoda sukcesji}

Metoda sukcesji na wejściu otrzymuje dwie populacje o rozmiarze $NP$: aktualną $P$ oraz populację mutantów $O$.
Wyjściem jest jedna populacja o rozmiarze $NP$.

\begin{algorithm}[!htb]
\begin{algorithmic}[1]
\Function{sukcesja}{}
  \For{$i = 0$ \bf{to} $i = NP - 1$}
    \If{$f(O(t, i)) < f(P(t, i)) $}
      \State $P(t+1, i) \gets O(t, i)$
    \Else
      \State $P(t+1, i) \gets P(t, i)$
    \EndIf
  \EndFor
\EndFunction
\end{algorithmic}
\end{algorithm}

\nocite{*}
\bibliographystyle{plain}
\bibliography{references}
\end{document}
