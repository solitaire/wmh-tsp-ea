\documentclass[12pt, a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{polski}
\usepackage{hyperref}
\usepackage{float}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{geometry}
\usepackage[table]{xcolor}
\title{\textbf{Zastosowanie algorytmu ewolucyjnego do rozwiązywania problemu komiwojażera}}
\author{Anna Stępień \\ Adam Stelmaszczyk}
\date{}
\setlength{\parindent}{0in}
\makeatletter\renewcommand{\ALG@name}{}

\begin{document}
\maketitle

\section{Zadanie}
Celem zadania jest zaprojektowanie algorytmu ewolucyjnego, który zostanie wykorzystany do rozwiązania problemu komiwojażera.
Zaprojektowana została reprezentacja rozwiązania, metoda sukcesji oraz operatory mutacji i krzyżowania. 
Z punktu widzenia przydatności projektowanego algorytmu, istotne jest przetestowanie go dla różnych parametrów, w szczególności dla:
\begin{itemize}
	\item różnych wartości prawdopodobieństwa mutacji $p_m$ i krzyżowania $p_c$,
	\item grafów o różnej liczbie wierzchołków $n$.
\end{itemize}

\section{Założenia}
Aplikacja będzie pracować w trybie konsolowym. Na standardowe wejście podawane będą pliki tekstowe zawierające opis grafów.
Program będzie wypisywał odpowiedź na standardowe wyjście.

\subsection{Reprezentacja rozwiązań}

Wierzchołki grafu numerujemy od 0 do $n - 1$. $n > 2$. Rozwiązanie reprezentujemy jako ciąg długości $n$, złożony z unikalnych liczb. 
Dla skrócenia zapisu stosujemy zapis 123, zamiast $(1,2,3)$. Przykładowo, w grafie pełnym o 3 wierzchołkach możliwych jest $3!$ rozwiązań: 123, 132, 213, 231, 312, 321.
Warto zauważyć, że połowę tych rozwiązań można pominąć, ze względu na to, że koszt przejścia z $a$ do $b$ jest zawsze 
taki sam jak z $b$ do $a$. Można zatem pominąć rozwiązania $231, 312, 321$. Pozostałe trzy rozwiązania mają identyczny koszt,
zatem dwa z nich również można pominąć. Tym samym jedyne interesujące nas rozwiązanie to $123$.
W ogólnym przypadku, dla grafu pełnego $n$ wierzchołkach, liczba interesujących nas rozwiązań wynosi $\frac{(n-1)!}{2}$. Spośród redundantnych rozwiązań pozostawiane będą te,
których reprezentacja liczbowa jest najmniejsza. Przykładowo, dla grafu pełnego o $4$ wierzchołkach zamiast rozpatrywać wszystkie
24 rozwiązania, będziemy rozpatrywać tylko 3: 1234, 1324, 1342. 
Wartość funkcji celu $f$ to suma wag krawędzi w cyklu dla danego rozwiązania.

\subsection{Schemat algorytmu ewolucyjnego}

\begin{algorithm}[!htb]
\label{ea}
\begin{algorithmic}[1]
\Function{algorytm\_ewolucyjny}{}
	\State $P(0) \gets \{x_1, x_2, \ldots, x_n\}$
	\State $t \gets 0$
	\While{$! stop$}
    	\For{$i = 0$ \bf{to} $i = n - 1$}
    		\If{$U(1) < p_c$}
    			\State $O(t,i) \gets mutacja(crossover(selekcja(P(t), 2)))$
    		\Else
    			\State $O(t,i) \gets mutacja(selekcja(P(t),1))$
    		\EndIf
    	\EndFor
    \State $P(t+1) \gets sukcesja(P(t),O(t))$
    \State $t \gets t+1$
  	\EndWhile
\EndFunction
\end{algorithmic}
\end{algorithm}

\subsection{Operator mutacji}

Operator mutacji otrzymuje na wejściu prawdopodobieństwo mutacji $p_m$ oraz rozwiązanie długości $n$.
Zwraca rozwiązanie długości $n$.

\begin{enumerate}
 \item Liczba powtórzeń $R = \lceil n \cdot  p_m \rceil$. Powtórz $R$ razy następujące kroki:
 \item Wylosuj indeks $i$ od 0 do $n-1$ zgodnie z rozkładem jednostajnym.
 \item Wylosuj indeks $j$ od 0 do $n-1$, ale różny od $i$, zgodnie z rozkładem jednostajnym.
 \item Zamień liczbę na pozycji $i$-tej w ciągu z liczbą na pozycji $j$-tej.
\end{enumerate}

\subsection{Operator krzyżowania}

Operator krzyżowania na wejściu otrzymuje dwa rozwiązania rodzicielskie długości $n$ i zwraca dwa rozwiązania potomne długości $n$. 

Jako operator krzyżowania zostanie wykorzystany operator krzyżowania z częściowym odwzorowaniem -- {PMX} (ang. partially mapped crossover).
\begin{enumerate}
 \item Wylosowanie dwóch liczb $i$, $j$ z przedziału od $0$ do $n-1$, takich, że $i \neq j$.
 \item Utwórz dwa rozwiązania potomne poprzez skopiowanie rozwiązań rodzicielskich, a następnie dokonaj wymiany rozwiązania dla sekwencji od $i$ do $j$.
 \item Na podstawie skopiowanej sekwencji od $i$ do $j$ utwórz wzajemne odwzorowanie rozwiązań rodzicielskich.
 \item Dokonanie ewentualnej korekty pozostałych części rozwiązania (od $0$ do $i-1$ i od $j+1$ do $n-1$). Korekta jest konieczna w przypadku, gdy w rozwiązaniu potomnym co najmniej jeden z wierzchołków jest powtórzony. Proces korekty przebiega następująco:
 \begin{enumerate}
 	\item Zidentyfikuj powtórzone wierzchołki w rozwiązaniu potomnym.
 	\item Dla każdego powtórzone wierzchołka w części rozwiązania od $0$ do $i-1$ i od $j+1$ do $n-1$ dokonaj zamiany z wierzchołkiem zgodnym z odwzorowaniem uzyskanym w poprzednim punkcie.
 \end{enumerate}
\end{enumerate}

Przykładowo, dla następujących rozwiązań rodzicielskich i $i = 2$ i $j = 5$:\\

Rodzic 1
\begin{tabular}{ | c | c | c | c | c | c | c | c |}
  \hline
  2 & 6 &  \cellcolor{green!25}7 & \cellcolor{green!25}1 & \cellcolor{green!25}5 & \cellcolor{green!25}4 & 8 & 3 \\ \hline
\end{tabular}\\

Rodzic 2
\begin{tabular}{ | c | c | c | c | c | c | c | c |}
  \hline
  7 & 5 & \cellcolor{blue!25}6 & \cellcolor{blue!25}3 & \cellcolor{blue!25}8 & \cellcolor{blue!25}2 & 1 & 4 \\ \hline
\end{tabular}\\

\begin{enumerate}
 	\item Krok 2 -- wymiana sekwencji\\
Potomek 1
\begin{tabular}{ | c | c | c | c | c | c | c | c |}
  \hline
  2 & 6 & \cellcolor{blue!25}6 & \cellcolor{blue!25}3 & \cellcolor{blue!25}8 & \cellcolor{blue!25}2 & 8 & 3 \\ \hline
\end{tabular}\\

Potomek 2
\begin{tabular}{ | c | c | c | c | c | c | c | c |}
  \hline
  7 & 5 &  \cellcolor{green!25}7 & \cellcolor{green!25}1 & \cellcolor{green!25}5 & \cellcolor{green!25}4 & 1 & 4 \\ \hline
\end{tabular}\\

\item Krok 3 -- utworzenie odwzorowania\\
$6 - 7$\\
$3 - 1$\\
$5 - 8$\\
$2 - 4$\\

\item Krok 4 -- korekta rozwiązania\\
Potomek 1
\begin{tabular}{ | c | c | c | c | c | c | c | c |}
  \hline
  4 & 7 & \cellcolor{blue!25}6 & \cellcolor{blue!25}3 & \cellcolor{blue!25}8 & \cellcolor{blue!25}2 & 5 & 1 \\ \hline
\end{tabular}\\

Potomek 2
\begin{tabular}{ | c | c | c | c | c | c | c | c |}
  \hline
  6 & 8 &  \cellcolor{green!25}7 & \cellcolor{green!25}1 & \cellcolor{green!25}5 & \cellcolor{green!25}4 & 3 & 2 \\ \hline
\end{tabular}\\
\end{enumerate}

\subsection{Metoda sukcesji}

Metoda sukcesji na wejściu otrzymuje dwie populacje o rozmiarze $NP$: aktualną $P$ oraz populację mutantów $O$.
Wyjściem jest jedna populacja o rozmiarze $NP$.

\begin{algorithm}[!htb]
\begin{algorithmic}[1]
\Function{sukcesja}{}
  \For{$i = 0$ \bf{to} $i = NP - 1$}
    \If{$f(O(t, i)) < f(P(t, i)) $}
      \State $P(t+1, i) \gets O(t, i)$
    \Else
      \State $P(t+1, i) \gets P(t, i)$
    \EndIf
  \EndFor
\EndFunction
\end{algorithmic}
\end{algorithm}

\nocite{*}
\bibliographystyle{plain}
\bibliography{references}
\end{document}
